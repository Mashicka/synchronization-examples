Создавање околина за тестирање решенија на проблемот: „Филозофи кои вечераат“
=============================================================================

Семинарска работа по предметот Оперативни Системи 2013/2014,<br />
Факултет за Информатички Науки и Компјутерско Инженерство

Семинарската работа е изработена од:<br />
Александар Митревски <br />
Гроздан Маџаров
 

1. Опис на проблемот
--------------------

N филозофи седат на кружна маса. Пред секој филозоф се наоѓа порција тестенини. Помеѓу секоја чинија се наоѓа по една вилушка – вкупно има N вилушки бидејќи постојат точно N филозофи. Секој филозоф своето време го поминува во јадење и мислење. За филозофот да може да јаде, потребно е да ги држи двете вилушки кои се наоѓаат до него. Било која вилушка може да биде на масата или во раката на само еден филозоф во било кое време. Може да се смета дека филозофите имаат бесконечно многу храна на своите чинии, а за јадење еден оброк на секој филозоф му е потребно конечно време.

Проблемот се состои во дизајнирање алгоритам кој доколку филозофите го следат ќе овозможи ниту еден филозоф да не изгладне и ќе овозможи максимален број филозофи да јадат истовремено.

2. Решение на проблемот
-----------------------

Во склоп на оваа семинарска работа одбрано е едно од предложените решенија<sup>1</sup> на Edsger Wybe Dijkstra кое тековно е познато како „Resource hierarchy solution“<sup>2</sup>, т.е. решение со формирање на хиерархија на ресурсите. Овој алгоритам гарантира дека нема да дојде до блокада или до изгладнување на било кој филозоф.

Решението се состои од подредување на ресурсите, или во овој случај, вилушките, и воведување на правилото дека филозофите секогаш прво ќе побараат вилушка со помал реден број, а откако ќе ја добијат, ќе побараат вилушка со поголем реден број.

Согледувањето на коректноста на решението може да се направи со пример. Нека N = 5 – пет филозофи седат на кружна маса, а истовремено има и 5 вилушки на масата. Филозофите и вилушките ги означуваме со броеви од 1 до 5 и притоа вилушката со реден број 1 се наоѓа на десната страна на филозофот означен со реден број 1 набљудувано од неговата перспектива. Да претпоставиме дека сите филозофи почнуваат да јадат одеднаш. Филозофот број 1 ја зема вилушката број 1 и чека да ја земе вилушката број 2 кој ја земал филозофот број 2 додека филозофот број 1 ја земал вилушката број 1. Филозофот број 2 чека да ја добие вилушката број 3 која ја земал филозофот број 3, а филозофот број 3 чека да ја добие вилушката број 4 која ја земал филозофот број 4. Благодарение на подредувањето на вилушките, филозофот број 5 нема да посегне по вилушката број 5 бидејќи најпрво му е потребна вилушката со број 1, па тој ќе чека филозофот број 1 да ја остави вилушката број 1 за самиот да може да ја земе пред да ја побара вилушката број 5. Благодарение на овој факт, филозофот број 4 ќе може да ја добие вилушката број 5 и откако ќе заврши со јадењето, ќе ги ослободи двете вилушки, со што филозофот број 3 ќе може веднаш да почне да јаде. На истиот начин, филозофите со броеви 3, 2 и 1 ќе завршат со јадење, по што филозофот број 5 ќе може да ја добие вилушката број 1, а потоа и вилушката број 5.

Забелешка: решението предложено од Andrew Stuart Tanenbaum<sup>3</sup> не е искористено во овој случај поради тоа што не овозможува сигурност дека ниту еден филозоф нема да изгладне.

3. Околина за решавање на проблемот
-----------------------------------

Околината за решавање на проблемот е имплементирана со помош на приложената архитектура од страна на менторот на семинарската работа. Авторите на оваа семинарска работа во склоп со овој документ приложуваат два .java документи со изворен код: `DiningPhilosophers.java` и `DiningPhilosophersState.java`.

**DiningPhilosophers.java**

Оваа класа го имплементира претходно опишаното решение. Јавната класа `DiningPhilosophers` дефинира класа `Philosopher` која претставува филозоф. Класата содржи покажувачи кон вилушките кои му се доделени на филозофот согласно со решението. Пред да земе да јаде, тој прво чека да ја добие вилушката со помал реден број, а потоа онаа со поголем. Откако ќе заврши со јадење и ќе ги остави вилушките, тој почнува да мисли.

Класата `DiningPhilosophers` содржи N семафори кои ги претставуваат вилушките на масата, а секој семафор е поддесен да пропушта само една нишка. `main()` методот во оваа класа го повикува само еднаш `run()` методот од истата класа – доколку има потреба од повторено извршување на циклусот, истото може да се изведе со промена на вредности на одредени променливи во самиот метод:

- `DiningPhilosophers.NUMBER_OF_PHILOSOPHERS` го означува бројот на филозофи кои седат на кружната маса – овој број останува ист за сите итерации доколку важи `step = 0`.
- `numRuns` е бројот на повторувања на `execute()` методот на секој филозоф.
- `numIterations` е бројот на изведувања на целиот алгоритам, т.е. бројот на маси околку кои седат филозофи кои ќе ги набљудуваме.
- `step` е вредноста на зголемувањето на бројот на филозофи кои седат на масата во секоја наредна итерација.

**DiningPhilosophersState.java**

Наведената класа ја имплементира контролната околина во која ќе се изведува настанот, т.е. масата со филозофите. При тестирање на решенија на проблемот „филозофи кои вечераат“ треба да се обрне внимание на појавата на следните настани:

1. Една вилушка се користи истовремено од повеќе од еден филозоф.
2. Блокада: состојба во која секој од филозофите чека некој друг да ослободи вилушка.
3. Изгладнување: барем еден филозоф не може да дојде на ред да ги земе вилушките.
4. Последователност: само еден филозоф јаде во било кој временски момент.

Доколку ниту еден од овие настани не се случи, тогаш решението е коректно.

Најважни методи во оваа класа се методите `eat()` и `think()` кои се повикуваат во `execute()` методот на `DiningPhilosophers.Philosopher` класата:

- `eat()` методот го имплементира процесот на јадење. Најпрво се забележува дека овој филозоф преминал во состојба „јадење“. Се проверува дали некој од соседите на овој филозоф, филзофите лево и десно од него, тековно јаде. Во таков случај се забележува исклучок, бидејќи дошло до појава на настан 1. од горенаведената листа. Се зголемува бројот на филозофи кои тековно јадат и нишката се суспендира одредено време за да се симулира јадење. Бројот на филозофи кои тековно јадат се намалува, а состојбата на филозофот се враќа во „размислување“ откако филозофот ќе заврши со јадење. Се напоменува дека состојбата „размислување“ во овој контекст претставува комплемент на состојбата „јадење“, т.е. филозоф во состојба „размислување“ може да не размислува, туку да чека вилушка за одново да почне да јаде.
- `think()` методот забележува дека филозофот преминал во состојба „размислување“ и ја суспендира нишката за да симулира поминување на време во мислење.

Други важни методи во оваа класа се: `clear()` методот кој ја враќа состојбата на тековниот `DiningPhilosophersState` објект во првобитната состојба, и `finalize()` методот кој врши проверка за појава на настаните 4. и 3. од горенаведената листа. Нема потреба од посебна проверка за појава на настанот 2. од листата (блокада) бидејќи самата архитектура проверува дали истиот се случил. Поради начинот на забележување на исклучоците во тековната архитектура, при случување на блокада се бележи дека се случило изгладнување иако станува збор за вистинска блокада која всушност е препознаена од самата архитектура. Овој проблем може да се заобиколи доколку се коментира линијата код `throw e;` во `logException()` методот на `AbstractState` класата – во таков случај, се забележува грешка изгладнување и грешка блокада.

Времето на суспендирање на нишките при јадењето и мислењето на филозофот е компаративно мало (од 1 до 10 милисекунди) што значи дека настанот не се симулира во реално време – ова се случува поради тоа што веќе воспоставената архитектура со помош на која се симулира настанот пријавува блокада доколку било која нишка се извршува подолго од 1 секунда (што може да се согледа во `startWithoutDeadlock()` методот на `ProblemExecution` класата).

Дополнителна документација може да се најде во самиот изворен код во вид на коментари.

4. Референци
------------
<sub>1. https://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD625.html, Second Solution. As seen on 14.09.2014.</sub><br />
<sub>2. http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD310.html. As seen on 14.09.2014.</sub><br />
<sub>3. Allen B. Downey, The Little Book Of Semaphores v.2.1.5, p. 103, 104</sub>
